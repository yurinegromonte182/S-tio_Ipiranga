// ============================================
// üó∫Ô∏è DETECTAR AUTOMATICAMENTE GEOMETRIAS DA TABELA
// ============================================
async function detectarGeometriasFrutiferas() {
  console.log('üîç Detectando colunas geom√©tricas na tabela frutiferas...');
  
  try {
    // 1. Primeiro, buscar estrutura da tabela
    const { data: estrutura, error: err1 } = await supabaseClient
      .from('frutiferas')
      .select('*')
      .limit(1);
    
    if (err1) throw err1;
    
    if (!estrutura || estrutura.length === 0) {
      console.warn('‚ö†Ô∏è Tabela frutiferas vazia ou sem dados');
      return [];
    }
    
    const primeiraLinha = estrutura[0];
    const colunasGeometricas = [];
    
    // 2. Identificar colunas que podem conter geometrias
    // (geralmente s√£o objetos ou strings JSON)
    for (const [coluna, valor] of Object.entries(primeiraLinha)) {
      if (valor === null || valor === undefined) continue;
      
      // Verificar se √© geometria pelos tipos comuns
      if (
        typeof valor === 'object' ||
        (typeof valor === 'string' && (
          valor.includes('POINT') ||
          valor.includes('LINESTRING') ||
          valor.includes('POLYGON') ||
          valor.includes('MULTI') ||
          valor.startsWith('{') ||
          valor.startsWith('[')
        ))
      ) {
        colunasGeometricas.push(coluna);
        console.log(`üìç Poss√≠vel coluna geom√©trica: ${coluna}`, typeof valor);
      }
    }
    
    console.log('‚úÖ Colunas geom√©tricas detectadas:', colunasGeometricas);
    return colunasGeometricas;
    
  } catch (error) {
    console.error('‚ùå Erro ao detectar geometrias:', error);
    return [];
  }
}

// ============================================
// üó∫Ô∏è CARREGAR TODAS AS GEOMETRIAS DA TABELA
// ============================================
async function carregarTodasGeometriasFrutiferas() {
  console.log('üó∫Ô∏è Carregando TODAS as geometrias da tabela frutiferas...');
  
  try {
    // Buscar TODOS os dados da tabela
    const { data: todasFrutiferas, error } = await supabaseClient
      .from('frutiferas')
      .select('*');
    
    if (error) throw error;
    
    if (!todasFrutiferas || todasFrutiferas.length === 0) {
      console.warn('‚ö†Ô∏è Nenhum dado encontrado na tabela frutiferas');
      return { pontos: [], linhas: [], poligonos: [] };
    }
    
    console.log(`üìä ${todasFrutiferas.length} registros carregados`);
    
    // Separar por tipo de geometria
    const geometrias = {
      pontos: [],
      linhas: [],
      poligonos: []
    };
    
    todasFrutiferas.forEach(registro => {
      // Verificar cada coluna em busca de geometrias
      for (const [coluna, valor] of Object.entries(registro)) {
        if (!valor) continue;
        
        // Determinar tipo de geometria pelo conte√∫do
        const tipo = determinarTipoGeometria(valor);
        
        if (tipo) {
          const feature = {
            type: 'Feature',
            geometry: converterParaGeoJSON(valor, tipo),
            properties: { ...registro, coluna_geometrica: coluna }
          };
          
          if (tipo === 'point') geometrias.pontos.push(feature);
          else if (tipo === 'linestring') geometrias.linhas.push(feature);
          else if (tipo === 'polygon') geometrias.poligonos.push(feature);
        }
      }
    });
    
    console.log(`üìç ${geometrias.pontos.length} pontos encontrados`);
    console.log(`üîÑ ${geometrias.linhas.length} linhas encontradas`);
    console.log(`üìê ${geometrias.poligonos.length} pol√≠gonos encontradas`);
    
    return geometrias;
    
  } catch (error) {
    console.error('‚ùå Erro ao carregar geometrias:', error);
    return { pontos: [], linhas: [], poligonos: [] };
  }
}

// ============================================
// üîß FUN√á√ïES AUXILIARES PARA GEOMETRIAS
// ============================================
function determinarTipoGeometria(valor) {
  const str = JSON.stringify(valor).toLowerCase();
  
  if (str.includes('point') || (typeof valor === 'object' && valor.x && valor.y)) {
    return 'point';
  }
  if (str.includes('linestring')) {
    return 'linestring';
  }
  if (str.includes('polygon')) {
    return 'polygon';
  }
  
  return null;
}

function converterParaGeoJSON(valor, tipo) {
  // Se j√° for objeto com coordenadas
  if (typeof valor === 'object' && valor.coordinates) {
    return {
      type: tipo === 'point' ? 'Point' : 
            tipo === 'linestring' ? 'LineString' : 'Polygon',
      coordinates: valor.coordinates
    };
  }
  
  // Se for string WKT (Well-Known Text)
  if (typeof valor === 'string') {
    return converterWKTparaGeoJSON(valor);
  }
  
  // Se for objeto simples com lat/lng
  if (typeof valor === 'object' && valor.latitude && valor.longitude) {
    return {
      type: 'Point',
      coordinates: [valor.longitude, valor.latitude]
    };
  }
  
  // Default: ponto com coordenadas 0,0
  return {
    type: 'Point',
    coordinates: [0, 0]
  };
}

function converterWKTparaGeoJSON(wkt) {
  // Simplificado - para produ√ß√£o use biblioteca como terraformer-wkt
  const upperWKT = wkt.toUpperCase();
  
  if (upperWKT.includes('POINT')) {
    const coords = wkt.match(/POINT\s*\(([^)]+)\)/i);
    if (coords && coords[1]) {
      const [lng, lat] = coords[1].trim().split(/\s+/).map(parseFloat);
      return {
        type: 'Point',
        coordinates: [lng, lat]
      };
    }
  }
  
  // Para outros tipos, retorna null (precisa de parser completo)
  return null;
}

// ============================================
// üé® CRIAR CAMADAS LEAFLET COM ESTILOS
// ============================================
function criarCamadasLeaflet(geometrias) {
  const camadas = {};
  
  // 1. Camada de Pontos (frut√≠feras individuais)
  if (geometrias.pontos.length > 0) {
    camadas.pontos = L.geoJSON({
      type: 'FeatureCollection',
      features: geometrias.pontos
    }, {
      pointToLayer: (feature, latlng) => {
        // Estilo baseado na esp√©cie
        const especie = feature.properties.nome_popular || 
                       feature.properties.especie || 
                       feature.properties.nome_cientifico || 
                       'Desconhecida';
        
        const cor = obterCorPorEspecie(especie);
        
        return L.circleMarker(latlng, {
          radius: 8,
          fillColor: cor,
          color: '#fff',
          weight: 2,
          opacity: 1,
          fillOpacity: 0.8
        });
      },
      onEachFeature: (feature, layer) => {
        const props = feature.properties;
        const popupContent = criarPopupFrutifera(props);
        layer.bindPopup(popupContent);
        
        // Eventos hover
        layer.on({
          mouseover: (e) => {
            e.target.setStyle({ radius: 10, fillOpacity: 1 });
          },
          mouseout: (e) => {
            e.target.setStyle({ radius: 8, fillOpacity: 0.8 });
          }
        });
      }
    });
    
    console.log(`‚úÖ Camada de pontos criada: ${geometrias.pontos.length} features`);
  }
  
  // 2. Camada de Linhas (cercas, divis√≥rias)
  if (geometrias.linhas.length > 0) {
    camadas.linhas = L.geoJSON({
      type: 'FeatureCollection',
      features: geometrias.linhas
    }, {
      style: {
        color: '#f59e0b',
        weight: 3,
        opacity: 0.8,
        dashArray: '5, 5'
      },
      onEachFeature: (feature, layer) => {
        const props = feature.properties;
        const popupContent = criarPopupGenerico(props, 'Linha/Divis√≥ria');
        layer.bindPopup(popupContent);
      }
    });
    
    console.log(`‚úÖ Camada de linhas criada: ${geometrias.linhas.length} features`);
  }
  
  // 3. Camada de Pol√≠gonos (talh√µes, √°reas)
  if (geometrias.poligonos.length > 0) {
    camadas.poligonos = L.geoJSON({
      type: 'FeatureCollection',
      features: geometrias.poligonos
    }, {
      style: {
        color: '#8b5cf6',
        weight: 2,
        fillColor: '#8b5cf6',
        fillOpacity: 0.3
      },
      onEachFeature: (feature, layer) => {
        const props = feature.properties;
        const popupContent = criarPopupGenerico(props, '√Årea/Talh√£o');
        layer.bindPopup(popupContent);
      }
    });
    
    console.log(`‚úÖ Camada de pol√≠gonos criada: ${geometrias.poligonos.length} features`);
  }
  
  return camadas;
}

// ============================================
// üìã FUN√á√ïES DE POPUP
// ============================================
function criarPopupFrutifera(props) {
  let html = `
    <div style="max-width: 300px; font-family: sans-serif;">
      <div style="background: #10b981; color: white; padding: 8px 12px; border-radius: 4px 4px 0 0; margin: -10px -10px 10px -10px;">
        <strong>üåø ${props.nome_popular || props.especie || 'Frut√≠fera'}</strong>
      </div>
  `;
  
  // Informa√ß√µes principais
  const infoBasica = [
    ['ID', props.fid || props.id],
    ['Esp√©cie', props.especie || props.nome_popular],
    ['Nome Cient√≠fico', props.nome_cientifico],
    ['Data Plantio', formatarData(props.data_plantio)],
    ['Respons√°vel', props.responsavel]
  ];
  
  infoBasica.forEach(([label, value]) => {
    if (value) {
      html += `<div style="margin-bottom: 4px;"><strong>${label}:</strong> ${value}</div>`;
    }
  });
  
  // Informa√ß√µes de localiza√ß√£o
  if (props.latitude && props.longitude) {
    html += `<div style="margin: 8px 0; padding: 6px; background: #f3f4f6; border-radius: 4px;">
      <strong>üìç Localiza√ß√£o:</strong><br>
      Lat: ${props.latitude}<br>
      Lng: ${props.longitude}
    </div>`;
  }
  
  // Informa√ß√µes t√©cnicas
  const infoTecnica = [
    ['Altura', props.altura_total, 'm'],
    ['Di√¢metro Copa', props.diametro_copa, 'm'],
    ['Volume Colhido', props.volume_colhido, 'kg']
  ];
  
  const temInfoTecnica = infoTecnica.some(([_, value]) => value);
  if (temInfoTecnica) {
    html += `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #e5e7eb;">
      <strong>üìä Dados T√©cnicos:</strong>`;
    
    infoTecnica.forEach(([label, value, unit]) => {
      if (value) {
        html += `<div style="margin-top: 2px;">${label}: ${value} ${unit || ''}</div>`;
      }
    });
    
    html += `</div>`;
  }
  
  html += `</div>`;
  return html;
}

function criarPopupGenerico(props, tipo) {
  let html = `
    <div style="max-width: 300px; font-family: sans-serif;">
      <div style="background: #6b7280; color: white; padding: 8px 12px; border-radius: 4px 4px 0 0; margin: -10px -10px 10px -10px;">
        <strong>üó∫Ô∏è ${tipo}</strong>
      </div>
  `;
  
  // Mostrar todas as propriedades (exceto geometria)
  let count = 0;
  for (const [key, value] of Object.entries(props)) {
    if (key.includes('geom') || key.includes('geometry') || !value) continue;
    
    html += `<div style="margin-bottom: 3px;">
      <strong>${formatarChave(key)}:</strong> ${formatarValor(value)}
    </div>`;
    count++;
  }
  
  if (count === 0) {
    html += `<div style="color: #9ca3af; font-style: italic;">
      Nenhuma informa√ß√£o adicional dispon√≠vel
    </div>`;
  }
  
  html += `</div>`;
  return html;
}

function formatarChave(key) {
  return key
    .split('_')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

function formatarValor(value) {
  if (typeof value === 'string' && value.match(/^\d{4}-\d{2}-\d{2}/)) {
    return formatarData(value);
  }
  return value;
}

// ============================================
// üó∫Ô∏è FUN√á√ÉO PRINCIPAL DO MAPA INTERATIVO
// ============================================
async function inicializarMapaInterativoCompleto() {
  console.log('üó∫Ô∏è Iniciando mapa interativo completo...');
  
  if (fullMap) {
    fullMap.remove();
  }
  
  // Criar mapa
  fullMap = L.map('fullMap').setView([-7.1195, -34.8450], 13);
  
  // Camadas base
  baseLayers.osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '¬© OpenStreetMap contributors',
    maxZoom: 19
  });
  
  baseLayers.satelite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
    attribution: 'Esri, Maxar, Earthstar Geographics',
    maxZoom: 19
  });
  
  // Adicionar camada base padr√£o
  baseLayers.osm.addTo(fullMap);
  currentBaseLayer = 'osm';
  
  // Mostrar loading
  mostrarToast('üó∫Ô∏è Carregando dados geoespaciais...', 'info');
  
  // 1. Detectar colunas geom√©tricas
  const colunasGeometricas = await detectarGeometriasFrutiferas();
  
  // 2. Carregar todas as geometrias
  const geometrias = await carregarTodasGeometriasFrutiferas();
  
  // 3. Criar camadas Leaflet
  const camadas = criarCamadasLeaflet(geometrias);
  
  // 4. Adicionar camadas ao mapa
  overlayLayers = {};
  
  if (camadas.pontos) {
    overlayLayers.pontos = camadas.pontos;
    camadas.pontos.addTo(fullMap);
    console.log('‚úÖ Camada de pontos adicionada ao mapa');
  }
  
  if (camadas.linhas) {
    overlayLayers.linhas = camadas.linhas;
    console.log('‚úÖ Camada de linhas configurada');
  }
  
  if (camadas.poligonos) {
    overlayLayers.poligonos = camadas.poligonos;
    console.log('‚úÖ Camada de pol√≠gonos configurada');
  }
  
  // 5. Adicionar controle de camadas
  if (Object.keys(overlayLayers).length > 0) {
    L.control.layers(baseLayers, overlayLayers).addTo(fullMap);
  }
  
  // 6. Adicionar escala
  L.control.scale({ imperial: false }).addTo(fullMap);
  
  // 7. Ajustar vista para todas as geometrias
  ajustarVistaMapa(geometrias);
  
  // 8. Adicionar legenda
  adicionarLegendaAoMapa();
  
  mostrarToast(`‚úÖ Mapa carregado: ${geometrias.pontos.length} pontos, ${geometrias.linhas.length} linhas, ${geometrias.poligonos.length} pol√≠gonos`, 'success');
}

function ajustarVistaMapa(geometrias) {
  const todosFeatures = [
    ...geometrias.pontos,
    ...geometrias.linhas,
    ...geometrias.poligonos
  ];
  
  if (todosFeatures.length === 0) {
    fullMap.setView([-7.1195, -34.8450], 13);
    return;
  }
  
  // Calcular bounds de todas as features
  const bounds = L.latLngBounds([]);
  
  todosFeatures.forEach(feature => {
    if (feature.geometry && feature.geometry.coordinates) {
      if (feature.geometry.type === 'Point') {
        const [lng, lat] = feature.geometry.coordinates;
        bounds.extend([lat, lng]);
      } else if (feature.geometry.type === 'LineString') {
        feature.geometry.coordinates.forEach(([lng, lat]) => {
          bounds.extend([lat, lng]);
        });
      } else if (feature.geometry.type === 'Polygon') {
        feature.geometry.coordinates[0].forEach(([lng, lat]) => {
          bounds.extend([lat, lng]);
        });
      }
    }
  });
  
  if (bounds.isValid()) {
    fullMap.fitBounds(bounds.pad(0.1));
  }
}

function adicionarLegendaAoMapa() {
  const legend = L.control({ position: 'bottomright' });
  
  legend.onAdd = function(map) {
    const div = L.DomUtil.create('div', 'info legend');
    div.style.backgroundColor = 'white';
    div.style.padding = '10px';
    div.style.borderRadius = '5px';
    div.style.boxShadow = '0 1px 5px rgba(0,0,0,0.4)';
    div.style.fontSize = '12px';
    
    let html = '<h4 style="margin: 0 0 8px 0; color: #374151;">üåø Legenda</h4>';
    
    // Pontos por esp√©cie (cores)
    const especiesUnicas = new Set();
    frutiferas.forEach(f => {
      const especie = f.especie || f.nome_popular;
      if (especie) especiesUnicas.add(especie);
    });
    
    const coresDisponiveis = ['#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#3b82f6', '#ec4899'];
    let i = 0;
    
    especiesUnicas.forEach(especie => {
      if (i < 6) { // Limitar a 6 cores
        const cor = coresDisponiveis[i];
        html += `<div style="margin-bottom: 4px; display: flex; align-items: center;">
          <div style="width: 12px; height: 12px; border-radius: 50%; background-color: ${cor}; border: 2px solid white; margin-right: 6px;"></div>
          <span>${especie}</span>
        </div>`;
        i++;
      }
    });
    
    // Linhas
    html += `<div style="margin-top: 8px; border-top: 1px solid #e5e7eb; padding-top: 8px;">
      <div style="margin-bottom: 4px; display: flex; align-items: center;">
        <div style="width: 20px; height: 3px; background-color: #f59e0b; margin-right: 6px;"></div>
        <span>Linhas/Divis√≥rias</span>
      </div>
      <div style="margin-bottom: 4px; display: flex; align-items: center;">
        <div style="width: 20px; height: 20px; border: 2px solid #8b5cf6; background-color: rgba(139, 92, 246, 0.3); margin-right: 6px;"></div>
        <span>√Åreas/Pol√≠gonos</span>
      </div>
    </div>`;
    
    div.innerHTML = html;
    return div;
  };
  
  legend.addTo(fullMap);
}

// ============================================
// üîÑ ATUALIZAR NO ARQUIVO PRINCIPAL
// ============================================

// Substituir a fun√ß√£o abrirMapaInterativo() por:
function abrirMapaInterativo() {
  document.getElementById('mapModal').classList.add('active');
  setTimeout(() => {
    inicializarMapaInterativoCompleto();
  }, 100);
}

// Adicionar bot√£o para recarregar camadas
function adicionarBotaoRecarregar() {
  const controls = document.querySelector('.map-controls');
  if (!controls) return;
  
  const botaoRecarregar = document.createElement('button');
  botaoRecarregar.className = 'map-control-btn';
  botaoRecarregar.innerHTML = '<i class="fas fa-sync-alt"></i> Recarregar';
  botaoRecarregar.onclick = async () => {
    mostrarToast('üîÑ Recarregando dados...', 'info');
    await inicializarMapaInterativoCompleto();
  };
  
  controls.appendChild(botaoRecarregar);
}
