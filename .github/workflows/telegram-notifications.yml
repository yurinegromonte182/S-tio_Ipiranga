name: Notifica√ß√µes Telegram - Supabase

on:
  schedule:
    # 06:00 BR = 09:00 UTC
    - cron: '0 9 * * *'
    # 12:00 BR = 15:00 UTC  
    - cron: '0 15 * * *'
    # 18:00 BR = 21:00 UTC
    - cron: '0 21 * * *'
  workflow_dispatch:

jobs:
  notify-telegram:
    runs-on: ubuntu-latest
    env:
      SUPABASE_URL: https://erbefbnjxgpetbetlzya.supabase.co
      SUPABASE_ANON_KEY: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImVyYmVmYm5qeGdwZXRiZXRsenlhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjEwMzI4ODcsImV4cCI6MjA3NjYwODg4N30.d09pjgddZpNY3Z4cVZ3V4h77aAf_GVGF0sOBTZkZf2A
      TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
      TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup environment
        run: |
          sudo apt-get update
          sudo apt-get install -y curl jq bc
      
      - name: Buscar dados e processar notifica√ß√£o
        run: |
          # Configurar fuso hor√°rio
          export TZ='America/Sao_Paulo'
          
          # Data atual
          HOJE=$(date +%Y-%m-%d)
          DATA_EXIBICAO=$(date +%d/%m/%Y)
          HORA_EXIBICAO=$(date +%H:%M)
          HORA_NUM=$(date +%H)
          
          # Fun√ß√£o para calcular dias (ajustada para datas NULL)
          dias_desde() {
            if [ -z "$1" ] || [ "$1" = "null" ] || [ "$1" = "" ]; then
              echo "999"
            else
              # Remover aspas se houver
              data_limpa=$(echo "$1" | tr -d '"')
              data_epoch=$(date -d "$data_limpa" +%s 2>/dev/null || echo "0")
              hoje_epoch=$(date -d "$HOJE" +%s)
              if [ "$data_epoch" = "0" ]; then
                echo "999"
              else
                echo $(( (hoje_epoch - data_epoch) / 86400 ))
              fi
            fi
          }
          
          echo "üîÑ Buscando dados do Supabase..."
          
          # URL para a fun√ß√£o RPC
          RPC_URL="${SUPABASE_URL}/rest/v1/rpc/get_plantas_para_telegram"
          
          # Buscar dados da fun√ß√£o RPC
          RESPONSE=$(curl -s -X POST \
            "$RPC_URL" \
            -H "apikey: $SUPABASE_ANON_KEY" \
            -H "Authorization: Bearer $SUPABASE_ANON_KEY" \
            -H "Content-Type: application/json" \
            -H "Prefer: return=minimal" \
            -d '{}')
          
          # DEBUG: Ver resposta bruta
          echo "üì¶ Resposta bruta (primeiros 500 chars):"
          echo "${RESPONSE:0:500}"
          
          # Verificar se a resposta √© v√°lida JSON
          if echo "$RESPONSE" | jq -e . >/dev/null 2>&1; then
            # A fun√ß√£o retorna um array dentro de json_agg
            # Se for um array direto
            if echo "$RESPONSE" | jq 'type' | grep -q "array"; then
              TOTAL=$(echo "$RESPONSE" | jq '. | length')
              echo "‚úÖ $TOTAL frut√≠feras encontradas"
              echo "$RESPONSE" > plantas.json
            # Se for um objeto com array
            elif echo "$RESPONSE" | jq 'has("json_agg")' 2>/dev/null | grep -q "true"; then
              TOTAL=$(echo "$RESPONSE" | jq '.json_agg | length')
              echo "‚úÖ $TOTAL frut√≠feras encontradas (via json_agg)"
              echo "$RESPONSE" | jq '.json_agg' > plantas.json
            else
              # Tentar extrair array de qualquer forma
              TOTAL=$(echo "$RESPONSE" | jq 'length' 2>/dev/null || echo "0")
              echo "‚ÑπÔ∏è  Estrutura diferente, tentando adaptar... Total: $TOTAL"
              echo "$RESPONSE" > plantas.json
            fi
          else
            echo "‚ùå ERRO: Resposta n√£o √© JSON v√°lido"
            echo "Resposta completa:"
            echo "$RESPONSE"
            
            # Usar backup local
            if [ -f "dados.geojson" ]; then
              echo "‚ö†Ô∏è Usando backup local..."
              TOTAL=$(jq '.features | length' dados.geojson 2>/dev/null || echo "0")
              echo "‚úÖ $TOTAL plantas no backup local"
              
              # Converter do GeoJSON para formato compat√≠vel
              jq '[.features[] | {
                id: (.properties.fid // .properties.id // "S/N"),
                nome: (.properties.nome_popular // "Frut√≠fera"),
                ultRega: (.properties.data_irrigacao_ordinaria // .properties.ultima_rega),
                ultPoda: (.properties.data_poda_formacao_1 // .properties.ultima_poda),
                ultColh: (.properties.inicio_colheita // .properties.ultima_colheita),
                dataPlantio: .properties.data_plantio
              }]' dados.geojson > plantas.json
            else
              TOTAL=0
              echo '[]' > plantas.json
            fi
          fi
          
          # Sauda√ß√£o
          if [ "$HORA_NUM" -lt 12 ]; then
            SAUDACAO="‚òÄÔ∏è Bom dia"
          elif [ "$HORA_NUM" -lt 18 ]; then
            SAUDACAO="‚õÖ Boa tarde"
          else
            SAUDACAO="üåô Boa noite"
          fi
          
          # Iniciar mensagem
          MESSAGE="${SAUDACAO}!%0A"
          MESSAGE="${MESSAGE}üåø *S√≠tio Ipiranga*%0A"
          MESSAGE="${MESSAGE}üìÖ ${DATA_EXIBICAO} √†s ${HORA_EXIBICAO}%0A"
          MESSAGE="${MESSAGE}üå≥ *${TOTAL} frut√≠feras* cadastradas%0A%0A"
          
          if [ "$TOTAL" -eq "0" ]; then
            MESSAGE="${MESSAGE}‚ö†Ô∏è *Nenhuma frut√≠fera encontrada*%0A"
          else
            # DEBUG: Ver primeira planta
            echo "üìÑ Primeira planta (amostra):"
            jq '.[0]' plantas.json
            
            # Arrays para a√ß√µes
            REGA_URG=""
            REGA_NORM=""
            PODA_PEND=""
            COLHEITA_PEND=""
            TOTAL_ACOES=0
            
            # Processar cada planta
            while IFS= read -r planta; do
              ID=$(echo "$planta" | jq -r '.id // "S/N"')
              NOME=$(echo "$planta" | jq -r '.nome // "Frut√≠fera"')
              ULT_REGA=$(echo "$planta" | jq -r '.ultRega')
              ULT_PODA=$(echo "$planta" | jq -r '.ultPoda')
              ULT_COLH=$(echo "$planta" | jq -r '.ultColh')
              
              # DEBUG: Ver valores
              # echo "ID: $ID, NOME: $NOME"
              # echo "ULT_REGA: $ULT_REGA, ULT_PODA: $ULT_PODA, ULT_COLH: $ULT_COLH"
              
              # Normalizar nome para min√∫sculas
              NOME_NORM=$(echo "$NOME" | tr '[:upper:]' '[:lower:]')
              
              # Determinar intervalos baseados no tipo
              if echo "$NOME_NORM" | grep -qi "mangabeira\|mangaba"; then
                REGA_INT=7; PODA_INT=180; COLHEITA_INT=90
                EMOJI="ü•≠"
              elif echo "$NOME_NORM" | grep -qi "caju\|cajueiro"; then
                REGA_INT=10; PODA_INT=365; COLHEITA_INT=60
                EMOJI="üå∞"
              elif echo "$NOME_NORM" | grep -qi "coq\|coqueiro\|coco"; then
                REGA_INT=5; PODA_INT=730; COLHEITA_INT=30
                EMOJI="ü••"
              elif echo "$NOME_NORM" | grep -qi "cacau"; then
                REGA_INT=3; PODA_INT=180; COLHEITA_INT=120
                EMOJI="üç´"
              else
                REGA_INT=7; PODA_INT=180; COLHEITA_INT=90
                EMOJI="üåø"
              fi
              
              # Verificar rega
              DIAS_R=$(dias_desde "$ULT_REGA")
              # echo "DIAS_R: $DIAS_R, REGA_INT: $REGA_INT"
              
              if [ "$DIAS_R" -ge $((REGA_INT + 2)) ]; then
                REGA_URG="${REGA_URG}‚Ä¢ üö® ${EMOJI} ${NOME} #${ID} - ${DIAS_R} dias%0A"
                TOTAL_ACOES=$((TOTAL_ACOES + 1))
              elif [ "$DIAS_R" -ge "$REGA_INT" ]; then
                REGA_NORM="${REGA_NORM}‚Ä¢ üíß ${EMOJI} ${NOME} #${ID} - ${DIAS_R} dias%0A"
                TOTAL_ACOES=$((TOTAL_ACOES + 1))
              fi
              
              # Verificar poda
              DIAS_P=$(dias_desde "$ULT_PODA")
              if [ "$DIAS_P" -ge "$PODA_INT" ]; then
                PODA_PEND="${PODA_PEND}‚Ä¢ ‚úÇÔ∏è ${EMOJI} ${NOME} #${ID} - ${DIAS_P} dias%0A"
                TOTAL_ACOES=$((TOTAL_ACOES + 1))
              fi
              
              # Verificar colheita
              DIAS_C=$(dias_desde "$ULT_COLH")
              if [ "$DIAS_C" -ge "$COLHEITA_INT" ]; then
                COLHEITA_PEND="${COLHEITA_PEND}‚Ä¢ üçé ${EMOJI} ${NOME} #${ID} - ${DIAS_C} dias%0A"
                TOTAL_ACOES=$((TOTAL_ACOES + 1))
              fi
              
            done < <(jq -c '.[]' plantas.json)
            
            # Montar mensagem final
            if [ "$TOTAL_ACOES" -eq 0 ]; then
              MESSAGE="${MESSAGE}‚úÖ *Tudo em dia!*%0ANenhuma a√ß√£o pendente.%0A"
            else
              MESSAGE="${MESSAGE}üìã *${TOTAL_ACOES} a√ß√£o(√µes) pendente(s):*%0A%0A"
              [ -n "$REGA_URG" ] && MESSAGE="${MESSAGE}üö® *URGENTE:*%0A${REGA_URG}%0A"
              [ -n "$REGA_NORM" ] && MESSAGE="${MESSAGE}üíß *Rega:*%0A${REGA_NORM}%0A"
              [ -n "$PODA_PEND" ] && MESSAGE="${MESSAGE}‚úÇÔ∏è *Poda:*%0A${PODA_PEND}%0A"
              [ -n "$COLHEITA_PEND" ] && MESSAGE="${MESSAGE}üçé *Colheita:*%0A${COLHEITA_PEND}%0A"
            fi
          fi
          
          MESSAGE="${MESSAGE}%0Aüì± *Acesse o app:*%0A"
          MESSAGE="${MESSAGE}https://yurimegromonte182.github.io/S-tio_Jintanga/"
          
          # Salvar mensagem para debug
          echo "=== MENSAGEM GERADA ==="
          echo -e "$MESSAGE" | sed 's/%0A/\n/g'
          echo "======================"
          
          # Enviar para Telegram
          echo "üì§ Enviando para Telegram..."
          TELEGRAM_RESPONSE=$(curl -s -X POST "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/sendMessage" \
            -d chat_id="$TELEGRAM_CHAT_ID" \
            -d text="$MESSAGE" \
            -d parse_mode="Markdown" \
            -w "\n%{http_code}")
          
          HTTP_CODE=$(echo "$TELEGRAM_RESPONSE" | tail -n1)
          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ Notifica√ß√£o enviada com sucesso!"
          else
            echo "‚ùå Erro ao enviar: HTTP $HTTP_CODE"
            echo "Resposta: $(echo "$TELEGRAM_RESPONSE" | head -n -1)"
          fi
          
          # Estat√≠sticas di√°rias (06h BR = 09:00 UTC)
          if [ "$HORA_NUM" -eq 6 ] || [ "$(date -u +%H)" -eq 9 ]; then
            if [ "$TOTAL" -gt "0" ]; then
              echo "üåÖ Enviando estat√≠sticas di√°rias..."
              
              # Contar por tipo
              COQUEIROS=0
              CAJUEIROS=0
              CACAU=0
              MANGABEIRA=0
              OUTRAS=0
              
              while IFS= read -r planta; do
                NOME=$(echo "$planta" | jq -r '.nome // ""' | tr '[:upper:]' '[:lower:]')
                
                if echo "$NOME" | grep -qi "coq\|coqueiro\|coco"; then
                  COQUEIROS=$((COQUEIROS + 1))
                elif echo "$NOME" | grep -qi "caju\|cajueiro"; then
                  CAJUEIROS=$((CAJUEIROS + 1))
                elif echo "$NOME" | grep -qi "cacau"; then
                  CACAU=$((CACAU + 1))
                elif echo "$NOME" | grep -qi "mangabeira\|mangaba"; then
                  MANGABEIRA=$((MANGABEIRA + 1))
                else
                  OUTRAS=$((OUTRAS + 1))
                fi
              done < <(jq -c '.[]' plantas.json)
              
              STATS="üìä *Resumo do S√≠tio:*%0A"
              STATS="${STATS}üå≥ Total: ${TOTAL} frut√≠feras%0A"
              [ "$COQUEIROS" -gt 0 ] && STATS="${STATS}ü•• Coqueiros: ${COQUEIROS}%0A"
              [ "$CAJUEIROS" -gt 0 ] && STATS="${STATS}üå∞ Cajueiros: ${CAJUEIROS}%0A"
              [ "$CACAU" -gt 0 ] && STATS="${STATS}üç´ Cacau: ${CACAU}%0A"
              [ "$MANGABEIRA" -gt 0 ] && STATS="${STATS}ü•≠ Mangabeiras: ${MANGABEIRA}%0A"
              [ "$OUTRAS" -gt 0 ] && STATS="${STATS}üåø Outras: ${OUTRAS}%0A"
              
              TELEGRAM_STATS_RESPONSE=$(curl -s -X POST "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/sendMessage" \
                -d chat_id="$TELEGRAM_CHAT_ID" \
                -d text="$STATS" \
                -d parse_mode="Markdown" \
                -w "\n%{http_code}")
              
              STATS_HTTP_CODE=$(echo "$TELEGRAM_STATS_RESPONSE" | tail -n1)
              if [ "$STATS_HTTP_CODE" = "200" ]; then
                echo "‚úÖ Estat√≠sticas enviadas!"
              else
                echo "‚ö†Ô∏è N√£o foi poss√≠vel enviar estat√≠sticas"
              fi
            fi
          fi
